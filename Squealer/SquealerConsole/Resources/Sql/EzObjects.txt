
go

declare @ezdrop varchar(max) =
(
	select string_agg(
		'drop '
		+case o.type
			when 'V' then 'view'
			when 'P' then 'procedure'
			when 'FN' then 'function'
		end
		+ concat(' [',s.name,'].[',o.name,']')
			,'; ')
		+ '; drop schema {Schema}'
	from sys.objects o
	join sys.schemas s
		on s.schema_id = o.schema_id
	where s.name = '{Schema}'
)
if @ezdrop is not null
	exec (@ezdrop)

go

if schema_id('{Schema}') is null
	exec ('create schema {Schema}')

go

create view {Schema}.filegroups as
select
	fg.name as filegroup_name
	,t.object_id
	,i.index_id
from
	sys.indexes i
join
	sys.filegroups fg
	on fg.data_space_id = i.data_space_id
join
	sys.tables t
	on t.object_id = i.object_id

go

create view {Schema}.objects as
select
	concat('[',s.name,'].[',o.name,']') as object_name
	,s.schema_id
	,o.object_id
	,s.name as schema_name
	,o.name as name
	,o.type
	,o.type_desc
	,concat('[',db_name(),']','.','[',s.name,']','.','[',o.name,']') as fqn
	,'drop '
	+ case
		when o.type = 'P' then 'PROCEDURE'
		when o.type = 'U' then 'TABLE'
		when o.type = 'FN' then 'FUNCTION'
		else o.type_desc
	end
	+ concat(' [',s.name,'].[',o.name,'];') collate SQL_Latin1_General_CP1_CI_AS as sql_drop_object
from
	sys.objects o
join
	sys.schemas s
	on s.schema_id = o.schema_id

go

create view {Schema}.tables as
select
	fg.filegroup_name
	,o.object_name as table_name
	,o.schema_id
	,o.object_id
	,o.schema_name
	,o.name as name
	,o.type
	,o.type_desc
	,o.fqn
	,t.temporal_type
	,t.temporal_type_desc
	,o.sql_drop_object
	,(select string_agg(concat('[',c.name,']'),',') within group (order by c.column_id ) from sys.columns c where c.object_id = t.object_id) as column_list
from
	sys.tables t
join
	{Schema}.objects o
	on o.object_id = t.object_id
join
	{Schema}.filegroups fg
	on fg.object_id = t.object_id
	and fg.index_id<2 -- heaps and clustered indexes

go

create view {Schema}.views as
select
	o.object_name as view_name
	,o.schema_id
	,o.object_id
	,o.schema_name
	,o.name
	,o.type
	,o.type_desc
	,o.fqn
	,o.sql_drop_object
	,(select string_agg(concat('[',c.name,']'),',') within group (order by c.column_id ) from sys.columns c where c.object_id = t.object_id) as column_list
from
	sys.views t
join
	{Schema}.objects o
	on o.object_id = t.object_id

go

create function {Schema}.leftnum
(
@s as varchar(1000)
)
returns float
as
begin

declare @i float = 0;

set @s = ltrim(@s);

while isnumeric(left(@s,@i+1)) = 1 and @i < len(@s)
	set @i = @i + 1;

if isnumeric(left(@s,@i)) = 0
	set @i = null
else
	set @i = left(@s,@i)

return @i
end

go

create function {Schema}.leftint
(
@s as varchar(1000)
)
returns int
as
begin

return {Schema}.leftnum(@s)

end

go

create function {Schema}.rightint
(
@s as varchar(1000)
)
returns int
as
begin

declare @i int = len(@s);

while isnumeric(right(@s,@i)) = 0 and @i > 0
	set @i = @i - 1

if isnumeric(right(@s,@i)) = 0
	set @i = 0
else
	set @i = right(@s,@i)

return @i
end

go

create function {Schema}.string_format
(
@s as varchar(1000) -- ex: 'Do not compare {0}s and {1}s.'
,@tokens varchar(1000) -- ex: '0apple,1orange'
)
returns varchar(1000)
as
begin

select
	@s = replace(@s,concat('{',ez.leftint(value),'}'),replace(value,ez.leftint(value),''))
from
	string_split(@tokens,',')

return @s
end

go

create view {Schema}.indexcolumns as
select
	i.name as index_name
	,i.index_id
	,t.schema_id
	,t.object_id
	,t.schema_name
	,t.table_name
	,ic.index_column_id
	,c.name as column_name
	,ic.column_id
	,ic.is_included_column
from
	sys.index_columns ic
join
	sys.indexes i
	on i.object_id = ic.object_id
	and i.index_id = ic.index_id
join
	sys.columns c
	on c.object_id = ic.object_id
	and c.column_id = ic.column_id
join
	{Schema}.tables t
	on t.object_id = ic.object_id

go

create view {Schema}.indexes as
select
	fg.filegroup_name
	,i.name as index_name
	,t.table_name
	,i.type
	,i.type_desc
	,i.index_id
	,t.object_id
	,t.type as object_type
	,t.type_desc as object_type_desc
	,(
		select
			string_agg(c.column_name,',') within group (order by c.column_id)
		from
			{Schema}.indexcolumns c
		where
			c.object_id = i.object_id
			and c.index_id = i.index_id
			and c.is_included_column = 0
	) as index_columns
	,(
		select
			string_agg(c.column_name,',') within group (order by c.column_id)
		from
			{Schema}.indexcolumns c
		where
			c.object_id = i.object_id
			and c.index_id = i.index_id
			and c.is_included_column = 1
	) as included_columns
from
	sys.indexes i
join
	{Schema}.tables t
	on t.object_id = i.object_id
join
	ez.filegroups fg
	on fg.object_id = i.object_id
	and fg.index_id = i.index_id
where
	i.type > 0

go

create view {Schema}.indexusage as
select
	i.table_name
	,i.index_name
	,i.index_id
	,i.type_desc
	,i.index_columns
	,i.included_columns
	,convert(float,1) * (st.user_seeks+st.user_scans) / isnull(nullif(st.user_updates,0),1) as usage_ratio
	,st.user_seeks
	,st.user_scans
	,st.user_lookups
	,st.user_updates
	,st.last_user_seek
	,st.last_user_scan
	,st.last_user_update
	,concat('drop index ',i.index_name,' on ',i.table_name) as sql_dropindex
from
	sys.dm_db_index_usage_stats st
join
	{Schema}.indexes i
	on i.object_id = st.object_id
	and i.index_id = st.index_id
where
	st.database_id = db_id()
	--and i.type = 2

go

create view {Schema}.columns as
select
	t.table_name
	,c.name as column_name
	,c.column_id
	,tp.name as type_name
	,c.max_length
	,c.precision
	,c.scale
	,c.is_nullable
	,t.temporal_type
	,t.temporal_type_desc
from
	ez.tables t
join
	sys.all_columns c
	on c.object_id = t.object_id
join
	sys.types tp
	on tp.system_type_id = c.system_type_id

go

create function {Schema}.trimx
(
@s as varchar(max)
)
returns varchar(max)
as
begin

while charindex(char(9),@s) > 0 -- tab
	set @s = replace(@s,char(9),' ');

while charindex(char(10),@s) > 0 -- line feed
	set @s = replace(@s,char(10),' ');

while charindex(char(13),@s) > 0 -- carriage return
	set @s = replace(@s,char(13),' ');

while charindex('  ',@s) > 0
	set @s = replace(@s,'  ',' ');

return ltrim(rtrim(@s))
end

go

create function {Schema}.trimxt
(
@schemaname as varchar(100)
,@tablename as varchar(100)
,@s as varchar(max)
)
returns varchar(max)
as
begin

return replace(replace({Schema}.trimx(@s),'SCHEMANAME',@schemaname),'TABLENAME',@tablename)
end

go
